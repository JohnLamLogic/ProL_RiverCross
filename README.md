# Prolog River-Crossing Puzzle Solver

A program that uses the declarative logic programming paradigm of Prolog to solve the classic "Farmer, Fox, Chicken, and Corn" river-crossing puzzle.

> A sample solution path generated by the Prolog solver, showing the sequence of states.

---

## Overview

This project demonstrates the power of logic programming by implementing a solver for the classic river-crossing puzzle. Instead of writing a step-by-step procedural algorithm, this program defines a set of facts and rules that describe the puzzle's environment: the initial state, the goal state, the valid moves, and the safety constraints. Prolog's built-in inference engine then uses these rules to find a valid sequence of moves to solve the puzzle.

---

## Features

- **Declarative Problem Solving**: The puzzle is solved by defining what is true about the system (the rules and constraints), not how to solve it step-by-step.
- **State-Space Representation**: The location of the farmer, fox, chicken, and corn is represented using a Prolog structure, `state(Fa, Fo, Ch, Co)`.
- **Constraint Checking**: The program uses `safe/1` rules to enforce the puzzle's constraints, preventing the engine from exploring invalid states (e.g., the fox cannot be left alone with the chicken).
- **Recursive Pathfinding**: A recursive predicate (`reach/4`) performs a depth-first search through the state space to find a valid path from the starting state to the goal state, avoiding repeated states.

---

## How It Works

The solution is modeled based on a few key logical principles:

### Facts

The program begins by defining simple, unchanging facts, such as:

```prolog
opp(w, e).  % west is the opposite of east
opp(e, w).
```

### Safety Rules

The `safe/1` predicate defines what constitutes a valid state. For example, it is not safe if the fox and chicken are on the same bank while the farmer is on the opposite bank. The solver will only consider states that satisfy these rules.

### Move Rules

The `move/2` predicate defines all possible legal moves. This includes the farmer crossing alone or with one of the items, but only if the resulting state is safe.

### Recursive Search

The core of the solver is the `reach/4` predicate, which recursively explores possible moves. It takes a starting state, a goal state, and a list of already visited states to find a valid path without getting caught in loops. The `solve/1` predicate initiates this search from the initial state `state(w, w, w, w)` to the final state `state(e, e, e, e)`.

---

## Code Snippet: A Move Rule

This rule defines a valid move: the farmer can move with the chicken (`FaCh`) from one bank to the opposite (`NFaCh`), but only if the new resulting state is safe.

```prolog
move(state(FaCh, Fo, FaCh, Co), state(NFaCh, Fo, NFaCh, Co)) :- 
    opp(FaCh, NFaCh), 
    safe(state(NFaCh, Fo, NFaCh, Co)).
```

---

## Technologies Used

- **Language**: Prolog (SWI-Prolog)
- **Paradigm**: Logic Programming, Declarative Programming
- **Core Concepts**: Knowledge Representation, Rule-Based Inference, Recursion, State-Space Search

---

## Getting Started

### Prerequisites

- A Prolog interpreter, such as the free and open-source [SWI-Prolog](https://www.swi-prolog.org/)

### Installation & Execution

1. **Save the Code**: Save the Prolog code into a file (e.g., `river_puzzle.pl`).

2. **Start the Prolog Interpreter**:\
   Open your terminal or command prompt and start the Prolog interpreter:

   ```bash
   swipl
   ```

3. **Consult the File**:\
   Load your program file into the interpreter:

   ```prolog
   ?- consult('river_puzzle.pl').
   ```

4. **Run the Solver**:\
   Execute the query to find a solution path:

   ```prolog
   ?- solve(Path).
   ```

5. **Find More Solutions**:\
   After the first solution is displayed, press the semicolon key (`;`) to search for additional solution paths, if any exist.


